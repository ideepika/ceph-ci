#!/usr/bin/env python3

DEFAULT_IMAGE='ceph/daemon-base'
DATA_DIR='/var/lib/ceph'
LOG_DIR='/var/log/ceph'
UNIT_DIR='/etc/systemd/system'
LOG_DIR_MODE=0o770
DATA_DIR_MODE=0o700
PODMAN_PREFERENCE = ['podman', 'docker']  # prefer podman to docker

"""
You can invoke ceph-daemon in two ways:

1. The normal way, at the command line.

2. By piping the script to the python3 binary.  In this latter case, you should
   prepend one or more lines to the beginning of the script.

   For arguments,

       injected_argv = [...]

   e.g.,

       injected_argv = ['ls']

   For reading stdin from the '--config-and-json -' argument,

       injected_stdin = '...'
"""

import argparse
import configparser
import json
import logging
import os
import socket
import subprocess
import sys
import tempfile
import time
import uuid
from distutils.spawn import find_executable

try:
    from StringIO import StringIO
except ImportError:
    pass
try:
    from io import StringIO
except ImportError:
    pass

logging.basicConfig(level=logging.INFO)

podman_path = None

##################################

def pathify(p):
    if '/' not in p:
        return './' + p
    return p

def get_hostname():
    return socket.gethostname()

def make_fsid():
    return str(uuid.uuid1())

def is_fsid(s):
    try:
        uuid.UUID(s)
    except ValueError:
        return False
    return True

def makedirs(dir, uid, gid, mode):
    os.makedirs(dir, exist_ok=True, mode=mode)
    os.chown(dir, uid, gid)
    os.chmod(dir, mode)   # the above is masked by umask...

def get_data_dir(fsid, t, n):
    return os.path.join(args.data_dir, fsid, '%s.%s' % (t, n))

def get_log_dir(fsid):
    return os.path.join(args.log_dir, fsid)

def make_data_dir_base(fsid, uid, gid):
    data_dir_base = os.path.join(args.data_dir, fsid)
    makedirs(data_dir_base, uid, gid, DATA_DIR_MODE)
    makedirs(os.path.join(data_dir_base, 'crash'), uid, gid, DATA_DIR_MODE)
    makedirs(os.path.join(data_dir_base, 'crash', 'posted'), uid, gid,
             DATA_DIR_MODE)
    return data_dir_base

def make_data_dir(fsid, daemon_type, daemon_id, uid=None, gid=None):
    if not uid:
        (uid, gid) = extract_uid_gid()
    make_data_dir_base(fsid, uid, gid)
    data_dir = get_data_dir(fsid, daemon_type, daemon_id)
    makedirs(data_dir, uid, gid, DATA_DIR_MODE)
    return data_dir

def make_log_dir(fsid, uid=None, gid=None):
    if not uid:
        (uid, gid) = extract_uid_gid()
    log_dir = get_log_dir(fsid)
    makedirs(log_dir, uid, gid, LOG_DIR_MODE)
    return log_dir

def find_program(filename):
    name = find_executable(filename)
    if name is None:
        raise ValueError(f'{filename} not found')
    return name

def get_unit_name(fsid, daemon_type, daemon_id):
    return 'ceph-%s@%s.%s' % (fsid, daemon_type, daemon_id)

def check_unit(unit_name):
    try:
        out = subprocess.check_output(['systemctl', 'is-enabled', unit_name])
        enabled = out.decode('utf-8').strip() == 'enabled'
    except Exception as e:
        logging.warning('unable to run systemctl' % e)
        enabled = False
    try:
        out = subprocess.check_output(['systemctl', 'is-active', unit_name])
        active = out.decode('utf-8').strip() == 'active'
    except Exception as e:
        logging.warning('unable to run systemctl: %s' % e)
        active = False
    return (enabled, active)

def get_legacy_config_fsid(cluster):
    try:
        config = configparser.ConfigParser()
        config.read('/etc/ceph/%s.conf' % cluster)
        if 'global' in config and 'fsid' in config['global']:
            return config['global']['fsid']
    except Exception as e:
        logging.warning('unable to parse \'fsid\' from \'[global]\' section of /etc/ceph/ceph.conf: %s' % e)
        return None
    return None

def get_legacy_daemon_fsid(cluster_name, daemon_type, daemon_id):
    fsid = None
    if daemon_type == 'osd':
        try:
            with open(os.path.join(args.data_dir,
                                   daemon_type,
                                   'ceph-%s' % daemon_id,
                                   'ceph_fsid'), 'r') as f:
                fsid = f.read().strip()
        except IOError:
            pass
    if not fsid:
        fsid = get_legacy_config_fsid(cluster)
    return fsid

def get_daemon_args(fsid, daemon_type, daemon_id):
    r = [
        '--default-log-to-file=false',
        '--default-log-to-stderr=true',
        ]
    if fsid and daemon_id:
        r += ['--default-admin-socket',
              '/var/run/ceph/' + fsid + '-' + daemon_type + '.' + daemon_id +
              '.asok']
    r += ['--setuser', 'ceph']
    r += ['--setgroup', 'ceph']
    return r

def create_daemon_dirs(fsid, daemon_type, daemon_id, uid, gid,
                       config=None, keyring=None):
    data_dir = make_data_dir(fsid, daemon_type, daemon_id)
    make_log_dir(fsid)

    if config:
        with open(data_dir + '/config', 'w') as f:
            os.fchown(f.fileno(), uid, gid)
            os.fchmod(f.fileno(), 0o600)
            f.write(config)
    if keyring:
        with open(data_dir + '/keyring', 'w') as f:
            os.fchmod(f.fileno(), 0o600)
            os.fchown(f.fileno(), uid, gid)
            f.write(keyring)

def get_config_and_keyring():
    if args.config_and_keyring:
        if args.config_and_keyring == '-':
            try:
                j = injected_stdin
            except NameError:
                j = sys.stdin.read()
        else:
            with open(args.config_and_keyring, 'r') as f:
                j = f.read()
        d = json.loads(j)
        config = d.get('config')
        keyring = d.get('keyring')
    else:
        if args.key:
            keyring = '[%s]\n\tkey = %s\n' % (args.name, args.key)
        elif args.keyring:
            with open(args.keyring, 'r') as f:
                keyring = f.read()
        else:
            raise RuntimeError('no keyring')
        with open(args.config, 'r') as f:
            config = f.read()
    return (config, keyring)

def get_config_and_both_keyrings():
    if args.config_and_keyrings == '-':
        try:
            j = injected_stdin
        except NameError:
            j = sys.stdin.read()
    else:
        with open(args.config_and_keyrings, 'r') as f:
            j = f.read()
    d = json.loads(j)
    (d.get('config'), d.get('keyring'), d.get('crash_keyring'))

def get_container_mounts(fsid, daemon_type, daemon_id):
    mounts = {}
    if fsid:
        log_dir = get_log_dir(fsid)
        mounts[log_dir] = '/var/log/ceph:z'
        mounts['/var/lib/ceph/%s/crash' % fsid] = '/var/lib/ceph/crash:z'

    if daemon_id:
        data_dir = get_data_dir(fsid, daemon_type, daemon_id)
        cdata_dir = '/var/lib/ceph/%s/ceph-%s' % (daemon_type, daemon_id)
        mounts[data_dir] = cdata_dir + ':z'
        mounts[data_dir + '/config'] = '/etc/ceph/ceph.conf:z'

    if daemon_type in ['mon', 'osd']:
        mounts['/dev'] = '/dev:z'  # FIXME: narrow this down?
        mounts['/run/udev'] = '/run/udev:z'
    if daemon_type == 'osd':
        mounts['/sys'] = '/sys:z'  # for numa.cc, pick_address, cgroups, ...
        mounts['/run/lvm'] = '/run/lvm:z'
        mounts['/run/lock/lvm'] = '/run/lock/lvm:z'

    return mounts

def get_container(fsid, daemon_type, daemon_id, privileged=False):
    podman_args = []
    if daemon_type == 'osd' or privileged:
        podman_args += ['--privileged']
    return CephContainer(
        image=args.image,
        entrypoint='/usr/bin/ceph-' + daemon_type,
        args=[
            '-n', '%s.%s' % (daemon_type, daemon_id),
            '-f', # foreground
        ] + get_daemon_args(fsid, daemon_type, daemon_id),
        podman_args=podman_args,
        volume_mounts=get_container_mounts(fsid, daemon_type, daemon_id),
        cname='ceph-%s-%s.%s' % (fsid, daemon_type, daemon_id),
    )

def extract_uid_gid():
    out = CephContainer(
        image=args.image,
        entrypoint='/usr/bin/grep',
        args=['ceph', '/etc/passwd'],
    ).run()
    (uid, gid) = out.split(':')[2:4]
    return (int(uid), int(gid))

def deploy_daemon(fsid, daemon_type, daemon_id, c, uid, gid,
                  config=None, keyring=None):
    if daemon_type == 'mon':
        # tmp keyring file
        tmp_keyring = tempfile.NamedTemporaryFile(mode='w')
        os.fchmod(tmp_keyring.fileno(), 0o600)
        os.fchown(tmp_keyring.fileno(), uid, gid)
        tmp_keyring.write(keyring)
        tmp_keyring.flush()

        # tmp config file
        tmp_config = tempfile.NamedTemporaryFile(mode='w')
        os.fchmod(tmp_config.fileno(), 0o600)
        os.fchown(tmp_config.fileno(), uid, gid)
        tmp_config.write(config)
        tmp_config.flush()

        # --mkfs
        create_daemon_dirs(fsid, daemon_type, daemon_id, uid, gid)
        mon_dir = get_data_dir(fsid, 'mon', daemon_id)
        log_dir = get_log_dir(fsid)
        out = CephContainer(
            image=args.image,
            entrypoint='/usr/bin/ceph-mon',
            args=['--mkfs',
                  '-i', daemon_id,
                  '--fsid', fsid,
                  '-c', '/tmp/config',
                  '--keyring', '/tmp/keyring',
            ] + get_daemon_args(fsid, 'mon', daemon_id),
            volume_mounts={
                log_dir: '/var/log/ceph:z',
                mon_dir: '/var/lib/ceph/mon/ceph-%s:z' % (daemon_id),
                tmp_keyring.name: '/tmp/keyring:z',
                tmp_config.name: '/tmp/config:z',
            },
        ).run()

        # write conf
        with open(mon_dir + '/config', 'w') as f:
            os.fchown(f.fileno(), uid, gid)
            os.fchmod(f.fileno(), 0o600)
            f.write(config)
    else:
        # dirs, conf, keyring
        create_daemon_dirs(
            fsid, daemon_type, daemon_id,
            uid, gid,
            config, keyring)

    if daemon_type == 'osd' and args.osd_fsid:
        pc = CephContainer(
            image=args.image,
            entrypoint='/usr/sbin/ceph-volume',
            args=[
                'lvm', 'activate',
                daemon_id, args.osd_fsid,
                '--no-systemd'
            ],
            podman_args=['--privileged'],
            volume_mounts=get_container_mounts(fsid, daemon_type, daemon_id),
            cname='ceph-%s-activate-%s.%s' % (fsid, daemon_type, daemon_id),
        )
        pc.run()

    deploy_daemon_units(fsid, daemon_type, daemon_id, c)

def deploy_daemon_units(fsid, daemon_type, daemon_id, c,
                        enable=True, start=True):
    # cmd
    data_dir = get_data_dir(fsid, daemon_type, daemon_id)
    with open(data_dir + '/cmd', 'w') as f:
        f.write('#!/bin/sh\n' + ' '.join(c.run_cmd()) + '\n')
        os.fchmod(f.fileno(), 0o700)

    # systemd
    install_base_units(fsid)
    unit = get_unit_file(fsid)
    unit_file = 'ceph-%s@.service' % (fsid)
    with open(args.unit_dir + '/' + unit_file + '.new', 'w') as f:
        f.write(unit)
        os.rename(args.unit_dir + '/' + unit_file + '.new',
                  args.unit_dir + '/' + unit_file)
    subprocess.check_output(['systemctl', 'daemon-reload'])

    unit_name = get_unit_name(fsid, daemon_type, daemon_id)
    if enable:
        subprocess.check_output(['systemctl', 'enable', unit_name])
    if start:
        subprocess.check_output(['systemctl', 'start', unit_name])

def install_base_units(fsid):
    """
    Set up ceph.target and ceph-$fsid.target units.
    """
    # global unit
    existed = os.path.exists(args.unit_dir + '/ceph.target')
    with open(args.unit_dir + '/ceph.target.new', 'w') as f:
        f.write('[Unit]\n'
                'Description=all ceph service\n'
                '\n'
                '[Install]\n'
                'WantedBy=multi-user.target\n')
        os.rename(args.unit_dir + '/ceph.target.new',
                  args.unit_dir + '/ceph.target')
    if not existed:
        subprocess.check_output(['systemctl', 'enable', 'ceph.target'])
        subprocess.check_output(['systemctl', 'start', 'ceph.target'])

    # cluster unit
    existed = os.path.exists(args.unit_dir + '/ceph-%s.target' % fsid)
    with open(args.unit_dir + '/ceph-%s.target.new' % fsid, 'w') as f:
        f.write('[Unit]\n'
                'Description=ceph cluster {fsid}\n'
                'PartOf=ceph.target\n'
                'Before=ceph.target\n'
                '\n'
                '[Install]\n'
                'WantedBy=multi-user.target ceph.target\n'.format(
                    fsid=fsid)
        )
        os.rename(args.unit_dir + '/ceph-%s.target.new' % fsid,
                  args.unit_dir + '/ceph-%s.target' % fsid)
    if not existed:
        subprocess.check_output(['systemctl', 'enable', 'ceph-%s.target' % fsid])
        subprocess.check_output(['systemctl', 'start', 'ceph-%s.target' % fsid])

def deploy_crash(fsid, uid, gid, config, keyring):
    crash_dir = os.path.join(args.data_dir, fsid, 'crash')
    makedirs(crash_dir, uid, gid, DATA_DIR_MODE)

    with open(os.path.join(crash_dir, 'keyring'), 'w') as f:
        os.fchmod(f.fileno(), 0o600)
        os.fchown(f.fileno(), uid, gid)
        f.write(keyring)
    with open(os.path.join(crash_dir, 'config'), 'w') as f:
        os.fchmod(f.fileno(), 0o600)
        os.fchown(f.fileno(), uid, gid)
        f.write(config)

    # ceph-crash unit
    existed = os.path.exists(args.unit_dir + '/ceph-%s-crash.service' % fsid)
    mounts = {
        crash_dir: '/var/lib/ceph/crash:z',
        os.path.join(crash_dir, 'config'): '/etc/ceph/ceph.conf:z',
        os.path.join(crash_dir, 'keyring'): '/etc/ceph/ceph.keyring:z',
    }
    c = CephContainer(
        image=args.image,
        entrypoint='/usr/bin/ceph-crash',
        args=['-n', 'client.crash.%s' % get_hostname()],
        volume_mounts=mounts,
        cname='ceph-%s-crash' % (fsid),
    )
    unit_name = 'ceph-%s-crash.service' % fsid
    with open(os.path.join(args.unit_dir, unit_name + '.new'), 'w') as f:
        f.write('[Unit]\n'
                'Description=ceph cluster {fsid} crash dump collector\n'
                'PartOf=ceph-{fsid}.target\n'
                'Before=ceph-{fsid}.target\n'
                '\n'
                '[Service]\n'
                'Type=simple\n'
                'ExecStart={cmd}\n'
                'ExecStop=-{podman_path} stop ceph-{fsid}-crash\n'
                'Restart=always\n'
                'RestartSec=10\n'
                'StartLimitInterval=10min\n'
                'StartLimitBurst=10\n'
                '\n'
                '[Install]\n'
                'WantedBy=ceph-{fsid}.target\n'.format(
                    podman_path=podman_path,
                    fsid=fsid,
                    cmd=' '.join(c.run_cmd()))
        )
        os.rename(os.path.join(args.unit_dir, unit_name + '.new'),
                  os.path.join(args.unit_dir, unit_name))
    if not existed:
        subprocess.check_output(['systemctl', 'enable', unit_name])
        subprocess.check_output(['systemctl', 'start', unit_name])


def get_unit_file(fsid):
    u = """[Unit]
Description=Ceph daemon for {fsid}

# According to:
#   http://www.freedesktop.org/wiki/Software/systemd/NetworkTarget
# these can be removed once ceph-mon will dynamically change network
# configuration.
After=network-online.target local-fs.target time-sync.target
Wants=network-online.target local-fs.target time-sync.target

PartOf=ceph-{fsid}.target
Before=ceph-{fsid}.target

[Service]
LimitNOFILE=1048576
LimitNPROC=1048576
EnvironmentFile=-/etc/environment
ExecStartPre=-{podman_path} rm ceph-{fsid}-%i
ExecStartPre=-mkdir -p /var/run/ceph
ExecStart={data_dir}/{fsid}/%i/cmd
ExecStop=-{podman_path} stop ceph-{fsid}-%i
ExecStopPost=-/bin/rm -f /var/run/ceph/{fsid}-%i.asok
Restart=on-failure
RestartSec=10s
TimeoutStartSec=120
TimeoutStopSec=15
StartLimitInterval=30min
StartLimitBurst=5

[Install]
WantedBy=ceph-{fsid}.target
""".format(
    podman_path=podman_path,
    fsid=fsid,
    data_dir=args.data_dir)
    return u

def gen_ssh_key(fsid):
    tmp_dir = tempfile.TemporaryDirectory()
    path = tmp_dir.name + '/key'
    subprocess.check_output([
        'ssh-keygen',
        '-C', 'ceph-%s' % fsid,
        '-N', '',
        '-f', path
    ])
    with open(path, 'r') as f:
        secret = f.read()
    with open(path + '.pub', 'r') as f:
        pub = f.read()
    os.unlink(path)
    os.unlink(path + '.pub')
    tmp_dir.cleanup()
    return (secret, pub)

##################################

class CephContainer:
    def __init__(self,
                 image,
                 entrypoint,
                 args=[],
                 volume_mounts={},
                 cname='',
                 podman_args=[]):
        self.image = image
        self.entrypoint = entrypoint
        self.args = args
        self.volume_mounts = volume_mounts
        self.cname = cname
        self.podman_args = podman_args

    def run_cmd(self):
        vols = sum(
            [['-v', f'{host_dir}:{container_dir}']
             for host_dir, container_dir in self.volume_mounts.items()], [])
        envs = [
            '-e', f'CONTAINER_IMAGE={self.image}',
            '-e', f'NODE_NAME={get_hostname()}',
        ]
        cname = ['--name', self.cname] if self.cname else []
        return [
            podman_path,
            'run',
            '--rm',
            '--net=host',
        ] + self.podman_args + cname + envs + vols + [
            '--entrypoint', self.entrypoint,
            self.image
        ] + self.args

    def shell_cmd(self):
        vols = sum(
            [['-v', f'{host_dir}:{container_dir}']
             for host_dir, container_dir in self.volume_mounts.items()], [])
        envs = [
            '-e', f'CONTAINER_IMAGE={self.image}',
            '-e', f'NODE_NAME={get_hostname()}',
        ]
        return [
            podman_path,
            'run',
            '-it',
            '--net=host',
            '--privileged',
        ] + self.podman_args + envs + vols + [
            '--entrypoint', '/bin/bash',
            self.image
        ]

    def exec_cmd(self, cmd):
        return [
            podman_path,
            'exec',
            '-it',
            self.cname,
        ] + cmd

    def run(self):
        logging.debug(self.run_cmd())
        return subprocess.check_output(self.run_cmd()).decode('utf-8')

##################################

def command_version():
    out = CephContainer(args.image, 'ceph', ['--version']).run()
    print(out.decode('utf-8'), end='')
    return 0

##################################

def command_bootstrap():
    fsid = args.fsid or make_fsid()
    hostname = get_hostname()
    mon_id = args.mon_id or hostname
    mgr_id = args.mgr_id or hostname
    logging.info('Cluster fsid: %s' % fsid)

    logging.info('Extracting ceph user uid/gid from container image...')
    (uid, gid) = extract_uid_gid()

    # create some initial keys
    logging.info('Creating initial keys...')
    mon_key = CephContainer(
        image=args.image,
        entrypoint='/usr/bin/ceph-authtool',
        args=['--gen-print-key'],
    ).run().strip()
    admin_key = CephContainer(
        image=args.image,
        entrypoint='/usr/bin/ceph-authtool',
        args=['--gen-print-key'],
    ).run().strip()
    mgr_key = CephContainer(
        image=args.image,
        entrypoint='/usr/bin/ceph-authtool',
        args=['--gen-print-key'],
    ).run().strip()
    crash_key = CephContainer(
        image=args.image,
        entrypoint='/usr/bin/ceph-authtool',
        args=['--gen-print-key'],
    ).run().strip()

    keyring = ('[mon.]\n'
               '\tkey = %s\n'
               '\tcaps mon = allow *\n'
               '[client.admin]\n'
               '\tkey = %s\n'
               '\tcaps mon = allow *\n'
               '\tcaps mds = allow *\n'
               '\tcaps mgr = allow *\n'
               '\tcaps osd = allow *\n'
               '[mgr.%s]\n'
               '\tkey = %s\n'
               '\tcaps mon = allow profile mgr\n'
               '\tcaps mds = allow *\n'
               '\tcaps osd = allow *\n'
               '[client.crash.%s]\n'
               '\tkey = %s\n'
               '\tcaps mon = allow profile crash\n'
               '\tcaps mgr = allow profile crash\n'
               % (mon_key, admin_key, mgr_id, mgr_key, hostname, crash_key))

    # tmp keyring file
    tmp_keyring = tempfile.NamedTemporaryFile(mode='w')
    os.fchmod(tmp_keyring.fileno(), 0o600)
    os.fchown(tmp_keyring.fileno(), uid, gid)
    tmp_keyring.write(keyring)
    tmp_keyring.flush()

    # config
    cp = configparser.ConfigParser()
    if args.config:
        cp.read(args.config)
    if args.mon_ip:
        addr_arg = '[v2:%s:3300,v1:%s:6789]' % (args.mon_ip, args.mon_ip)
    elif args.mon_addrv:
        addr_arg = args.mon_addrv
    else:
        raise RuntimeError('must specify --mon-ip or --mon-addrv')
    cp['global']['fsid'] = fsid;
    cp['global']['mon host'] = addr_arg
    with StringIO() as f:
        cp.write(f)
        config = f.getvalue()

    # create initial monmap, tmp monmap file
    logging.info('Creating initial monmap...')
    tmp_monmap = tempfile.NamedTemporaryFile(mode='w')
    os.fchmod(tmp_monmap.fileno(), 0o644)
    out = CephContainer(
        image=args.image,
        entrypoint='/usr/bin/monmaptool',
        args=['--create',
              '--clobber',
              '--fsid', fsid,
              '--addv', mon_id, addr_arg,
              '/tmp/monmap'
        ],
        volume_mounts={
            tmp_monmap.name: '/tmp/monmap:z',
        },
    ).run()

    # create mon
    logging.info('Creating mon...')
    create_daemon_dirs(fsid, 'mon', mon_id, uid, gid)
    mon_dir = get_data_dir(fsid, 'mon', mon_id)
    log_dir = get_log_dir(fsid)
    out = CephContainer(
        image=args.image,
        entrypoint='/usr/bin/ceph-mon',
        args=['--mkfs',
              '-i', mon_id,
              '--fsid', fsid,
              '-c', '/dev/null',
              '--monmap', '/tmp/monmap',
              '--keyring', '/tmp/keyring',
        ] + get_daemon_args(fsid, 'mon', mon_id),
        volume_mounts={
            log_dir: '/var/log/ceph:z',
            mon_dir: '/var/lib/ceph/mon/ceph-%s:z' % (mon_id),
            tmp_keyring.name: '/tmp/keyring:z',
            tmp_monmap.name: '/tmp/monmap:z',
        },
    ).run()

    with open(mon_dir + '/config', 'w') as f:
        os.fchown(f.fileno(), uid, gid)
        os.fchmod(f.fileno(), 0o600)
        f.write(config)

    mon_c = get_container(fsid, 'mon', mon_id)
    deploy_daemon_units(fsid, 'mon', mon_id, mon_c)

    # create mgr
    logging.info('Creating mgr...')
    mgr_keyring = '[mgr.%s]\n\tkey = %s\n' % (mgr_id, mgr_key)
    mgr_c = get_container(fsid, 'mgr', mgr_id)
    deploy_daemon(fsid, 'mgr', mgr_id, mgr_c, uid, gid, config, mgr_keyring)

    # crash unit
    deploy_crash(fsid, uid, gid, config,
                 '[client.crash.%s]\n\tkey = %s\n' % (hostname, crash_key))

    # output files
    if args.output_keyring:
        with open(args.output_keyring, 'w') as f:
            os.fchmod(f.fileno(), 0o600)
            f.write('[client.admin]\n'
                    '\tkey = ' + admin_key + '\n')
        logging.info('Wrote keyring to %s' % args.output_keyring)
    if args.output_config:
        with open(args.output_config, 'w') as f:
            f.write(config)
        logging.info('Wrote config to %s' % args.output_config)

    logging.info('Waiting for mgr to start...')
    while True:
        out = CephContainer(
            image=args.image,
            entrypoint='/usr/bin/ceph',
            args=[
                '-n', 'mon.',
                '-k', '/var/lib/ceph/mon/ceph-%s/keyring' % mon_id,
                '-c', '/var/lib/ceph/mon/ceph-%s/config' % mon_id,
                'status', '-f', 'json-pretty'],
            volume_mounts={
                mon_dir: '/var/lib/ceph/mon/ceph-%s:z' % (mon_id),
            },
        ).run()
        j = json.loads(out)
        if j.get('mgrmap', {}).get('available', False):
            break
        logging.info('mgr is still not available yet, waiting...')
        time.sleep(1)

    # ssh
    if not args.skip_ssh:
        logging.info('Generating ssh key...')
        (ssh_key, ssh_pub) = gen_ssh_key(fsid)

        tmp_key = tempfile.NamedTemporaryFile(mode='w')
        os.fchmod(tmp_key.fileno(), 0o600)
        os.fchown(tmp_key.fileno(), uid, gid)
        tmp_key.write(ssh_key)
        tmp_key.flush()
        tmp_pub = tempfile.NamedTemporaryFile(mode='w')
        os.fchmod(tmp_pub.fileno(), 0o600)
        os.fchown(tmp_pub.fileno(), uid, gid)
        tmp_pub.write(ssh_pub)
        tmp_pub.flush()

        if args.output_pub_ssh_key:
            with open(args.output_put_ssh_key, 'w') as f:
                f.write(ssh_pub)
            logging.info('Wrote public SSH key to to %s' % args.output_pub_ssh_key)

        CephContainer(
            image=args.image,
            entrypoint='/usr/bin/ceph',
            args=[
                '-n', 'mon.',
                '-k', '/var/lib/ceph/mon/ceph-%s/keyring' % mon_id,
                '-c', '/var/lib/ceph/mon/ceph-%s/config' % mon_id,
                'config-key',
                'set',
                'mgr/ssh/ssh_identity_key',
                '-i', '/tmp/key'],
            volume_mounts={
                mon_dir: '/var/lib/ceph/mon/ceph-%s:z' % (mon_id),
                tmp_key.name: '/tmp/key:z',
            },
        ).run()
        CephContainer(
            image=args.image,
            entrypoint='/usr/bin/ceph',
            args=[
                '-n', 'mon.',
                '-k', '/var/lib/ceph/mon/ceph-%s/keyring' % mon_id,
                '-c', '/var/lib/ceph/mon/ceph-%s/config' % mon_id,
                'config-key',
                'set',
                'mgr/ssh/ssh_identity_pub',
                '-i', '/tmp/pub'],
            volume_mounts={
                mon_dir: '/var/lib/ceph/mon/ceph-%s:z' % (mon_id),
                tmp_pub.name: '/tmp/pub:z',
            },
        ).run()

        logging.info('Adding key to root@localhost\'s authorized_keys...')
        with open('/root/.ssh/authorized_keys', 'a') as f:
            os.fchmod(f.fileno(), 0o600)  # just in case we created it
            f.write(ssh_pub + '\n')

        logging.info('Enabling ssh module...')
        CephContainer(
            image=args.image,
            entrypoint='/usr/bin/ceph',
            args=[
                '-n', 'mon.',
                '-k', '/var/lib/ceph/mon/ceph-%s/keyring' % mon_id,
                '-c', '/var/lib/ceph/mon/ceph-%s/config' % mon_id,
                'mgr', 'module', 'enable', 'ssh'
            ],
            volume_mounts={
                mon_dir: '/var/lib/ceph/mon/ceph-%s:z' % (mon_id),
                tmp_pub.name: '/tmp/pub:z',
            },
        ).run()
        logging.info('Setting orchestrator backend to ssh...')
        CephContainer(
            image=args.image,
            entrypoint='/usr/bin/ceph',
            args=[
                '-n', 'mon.',
                '-k', '/var/lib/ceph/mon/ceph-%s/keyring' % mon_id,
                '-c', '/var/lib/ceph/mon/ceph-%s/config' % mon_id,
                'orchestrator', 'set', 'backend', 'ssh'
            ],
            volume_mounts={
                mon_dir: '/var/lib/ceph/mon/ceph-%s:z' % (mon_id),
                tmp_pub.name: '/tmp/pub:z',
            },
        ).run()
        host = get_hostname()
        logging.info('Adding host %s...' % host)
        CephContainer(
            image=args.image,
            entrypoint='/usr/bin/ceph',
            args=[
                '-n', 'mon.',
                '-k', '/var/lib/ceph/mon/ceph-%s/keyring' % mon_id,
                '-c', '/var/lib/ceph/mon/ceph-%s/config' % mon_id,
                'orchestrator', 'host', 'add', host
            ],
            volume_mounts={
                mon_dir: '/var/lib/ceph/mon/ceph-%s:z' % (mon_id),
                tmp_pub.name: '/tmp/pub:z',
            },
        ).run()
    return 0

##################################

def command_deploy():
    (daemon_type, daemon_id) = args.name.split('.')
    if daemon_type not in ['mon', 'mgr', 'mds', 'osd', 'rgw']:
        raise RuntimeError('daemon type %s not recognized' % daemon_type)
    (config, keyring, crash_keyring) = get_config_and_both_keyrings()
    if daemon_type == 'mon':
        if args.mon_ip:
            config += '[mon.%s]\n\tpublic_addr = %s\n' % (daemon_id, args.mon_ip)
        elif args.mon_network:
            config += '[mon.%s]\n\tpublic_network = %s\n' % (daemon_id,
                                                             args.mon_network)
        else:
            raise RuntimeError('must specify --mon-ip or --mon-network')
    (uid, gid) = extract_uid_gid()
    c = get_container(args.fsid, daemon_type, daemon_id)
    deploy_daemon(args.fsid, daemon_type, daemon_id, c, uid, gid,
                  config, keyring)
    deploy_crash(args.fsid, uid, gid, config, crash_keyring)

##################################

def command_run():
    (daemon_type, daemon_id) = args.name.split('.')
    c = get_container(args.fsid, daemon_type, daemon_id)
    subprocess.call(c.run_cmd())

##################################

def command_shell():
    if args.fsid:
        make_log_dir(args.fsid)
    if args.name:
        if '.' in args.name:
            (daemon_type, daemon_id) = args.name.split('.')
        else:
            daemon_type = args.name
            daemon_id = None
    else:
        daemon_type = 'osd'  # get the most mounts
        daemon_id = None
    mounts = get_container_mounts(args.fsid, daemon_type, daemon_id)
    if args.config:
        mounts[pathify(args.config)] = '/etc/ceph/ceph.conf:z'
    if args.keyring:
        mounts[pathify(args.keyring)] = '/etc/ceph/ceph.keyring:z'
    c = CephContainer(
        image=args.image,
        entrypoint='doesnotmatter',
        args=[],
        podman_args=['--privileged'],
        volume_mounts=mounts)
    subprocess.call(c.shell_cmd())

##################################

def command_enter():
    (daemon_type, daemon_id) = args.name.split('.')
    c = get_container(args.fsid, daemon_type, daemon_id)
    subprocess.call(c.exec_cmd(['bash']))

##################################

def command_exec():
    (daemon_type, daemon_id) = args.name.split('.')
    c = get_container(args.fsid, daemon_type, daemon_id,
                      privileged=args.privileged)
    subprocess.call(c.exec_cmd(args.command))

##################################

def command_ceph_volume():
    make_log_dir(args.fsid)

    mounts = get_container_mounts(args.fsid, 'osd', None)

    tmp_config = None
    tmp_keyring = None

    if args.config_and_keyring:
        # note: this will always pull from args.config_and_keyring (we
        # require it) and never args.config or args.keyring.
        (config, keyring) = get_config_and_keyring()

        # tmp keyring file
        tmp_keyring = tempfile.NamedTemporaryFile(mode='w')
        os.fchmod(tmp_keyring.fileno(), 0o600)
        tmp_keyring.write(keyring)
        tmp_keyring.flush()

        # tmp config file
        tmp_config = tempfile.NamedTemporaryFile(mode='w')
        os.fchmod(tmp_config.fileno(), 0o600)
        tmp_config.write(config)
        tmp_config.flush()

        mounts[tmp_config.name] = '/etc/ceph/ceph.conf:z'
        mounts[tmp_keyring.name] = '/var/lib/ceph/bootstrap-osd/ceph.keyring:z'

    c = CephContainer(
        image=args.image,
        entrypoint='/usr/sbin/ceph-volume',
        args=args.command,
        podman_args=['--privileged'],
        volume_mounts=mounts,
    )
    subprocess.call(c.run_cmd())

##################################

def command_unit():
    (daemon_type, daemon_id) = args.name.split('.')
    unit_name = get_unit_name(args.fsid, daemon_type, daemon_id)
    subprocess.call([
        'systemctl',
        args.command,
        unit_name])

##################################

def command_ls():
    ls = []

    # /var/lib/ceph
    if os.path.exists(args.data_dir):
        for i in os.listdir(args.data_dir):
            if i in ['mon', 'osd', 'mds', 'mgr']:
                daemon_type = i
                for j in os.listdir(os.path.join(args.data_dir, i)):
                    if '-' not in j:
                        continue
                    (cluster, daemon_id) = j.split('-', 1)
                    fsid = get_legacy_daemon_fsid(cluster, daemon_type,
                                                  daemon_id) or 'unknown'
                    (enabled, active) = check_unit('ceph-%s@%s' % (daemon_type,
                                                                   daemon_id))
                    ls.append({
                        'style': 'legacy',
                        'name': '%s.%s' % (daemon_type, daemon_id),
                        'fsid': fsid,
                        'enabled': enabled,
                        'active': active,
                    })
            elif is_fsid(i):
                fsid = i
                for j in os.listdir(os.path.join(args.data_dir, i)):
                    (daemon_type, daemon_id) = j.split('.', 1)
                    (enabled, active) = check_unit(get_unit_name(fsid,
                                                                 daemon_type,
                                                                 daemon_id))
                    ls.append({
                        'style': 'ceph-daemon:v1',
                        'name': '%s.%s' % (daemon_type, daemon_id),
                        'fsid': fsid,
                        'enabled': enabled,
                        'active': active,
                    })

    # /var/lib/rook
    # WRITE ME

    print(json.dumps(ls, indent=4))

##################################

def command_adopt():
    (daemon_type, daemon_id) = args.name.split('.')
    (uid, gid) = extract_uid_gid()
    if args.style == 'legacy':
        fsid = get_legacy_daemon_fsid(args.cluster, daemon_type, daemon_id)
        if not fsid:
            raise RuntimeError('could not detect fsid; add fsid = to ceph.conf')

        # NOTE: implicit assumption here that the units correspond to the
        # cluster we are adopting based on the /etc/{defaults,sysconfig}/ceph
        # CLUSTER field.
        unit_name = 'ceph-%s@%s' % (daemon_type, daemon_id)
        (enabled, active) = check_unit(unit_name)

        if active:
            logging.info('Stopping old systemd unit %s...' % unit_name)
            subprocess.check_output(['systemctl', 'stop', unit_name])
        if enabled:
            logging.info('Disabling old systemd unit %s...' % unit_name)
            subprocess.check_output(['systemctl', 'disable', unit_name])

        logging.info('Moving data...')
        make_data_dir_base(fsid, uid, gid)
        data_dir = get_data_dir(fsid, daemon_type, daemon_id)
        subprocess.check_output([
            'mv',
            '/var/lib/ceph/%s/%s-%s' % (daemon_type, args.cluster, daemon_id),
            data_dir])
        subprocess.check_output([
            'cp',
            '/etc/ceph/%s.conf' % args.cluster,
            os.path.join(data_dir, 'config')])
        os.chmod(data_dir, DATA_DIR_MODE)
        os.chown(data_dir, uid, gid)

        logging.info('Moving logs...')
        log_dir = make_log_dir(fsid, uid=uid, gid=gid)
        try:
            subprocess.check_output(
                ['mv',
                 '/var/log/ceph/%s-%s.%s.log*' % (args.cluster,
                                                  daemon_type, daemon_id),
                 os.path.join(log_dir)],
                shell=True)
        except Exception as e:
            logging.warning('unable to move log file: %s' % e)
            pass

        logging.info('Creating new units...')
        c = get_container(fsid, daemon_type, daemon_id)
        deploy_daemon_units(fsid, daemon_type, daemon_id, c,
                            enable=True,  # unconditionally enable the new unit
                            start=active)
    else:
        raise RuntimeError('adoption of style %s not implemented' % args.style)

##################################

def command_rm_daemon():
    (daemon_type, daemon_id) = args.name.split('.')
    if daemon_type in ['mon', 'osd'] and not args.force:
        raise RuntimeError('must pass --force to proceed: '
                           'this command may destroy precious data!')
    unit_name = get_unit_name(args.fsid, daemon_type, daemon_id)
    subprocess.check_output(['systemctl', 'stop', unit_name])
    subprocess.check_output(['systemctl', 'disable', unit_name])
    data_dir = get_data_dir(args.fsid, daemon_type, daemon_id)
    subprocess.check_output(['rm', '-rf', data_dir])

##################################

def command_rm_cluster():
    if not args.force:
        raise RuntimeError('must pass --force to proceed: '
                           'this command may destroy precious data!')

    unit_name = 'ceph-%s.target' % args.fsid
    try:
        subprocess.check_output(['systemctl', 'stop', unit_name])
        subprocess.check_output(['systemctl', 'disable', unit_name])
    except subprocess.CalledProcessError:
        pass
    crash_unit_name = 'ceph-%s-crash.service' % args.fsid
    try:
        subprocess.check_output(['systemctl', 'stop', crash_unit_name])
        subprocess.check_output(['systemctl', 'disable', crash_unit_name])
    except subprocess.CalledProcessError:
        pass

    slice_name = 'system-%s.slice' % (
        ('ceph-%s' % args.fsid).replace('-', '\\x2d'))
    try:
        subprocess.check_output(['systemctl', 'stop', slice_name])
    except subprocess.CalledProcessError:
        pass

    # FIXME: stop + disable individual daemon units, too?

    # rm units
    subprocess.check_output(['rm', '-f', args.unit_dir +
                             '/ceph-%s@.service' % args.fsid])
    subprocess.check_output(['rm', '-f', args.unit_dir +
                             '/ceph-%s-crash.service' % args.fsid])
    subprocess.check_output(['rm', '-f', args.unit_dir +
                             '/ceph-%s.target' % args.fsid])
    subprocess.check_output(['rm', '-rf',
                  args.unit_dir + '/ceph-%s.target.wants' % args.fsid])
    # rm data
    subprocess.check_output(['rm', '-rf', args.data_dir + '/' + args.fsid])
    # rm logs
    subprocess.check_output(['rm', '-rf', args.log_dir + '/' + args.fsid])
    subprocess.check_output(['rm', '-rf', args.log_dir +
                             '/*.wants/ceph-%s@*' % args.fsid])


##################################

parser = argparse.ArgumentParser(
    description='Bootstrap Ceph daemons with systemd and containers.',
    formatter_class=argparse.ArgumentDefaultsHelpFormatter)
parser.add_argument(
    '--image',
    default=DEFAULT_IMAGE,
    help='container image')
parser.add_argument(
    '--docker',
    action='store_true',
    help='use docker instead of podman')
parser.add_argument(
    '--data-dir',
    default=DATA_DIR,
    help='base directory for daemon data')
parser.add_argument(
    '--log-dir',
    default=LOG_DIR,
    help='base directory for daemon logs')
parser.add_argument(
    '--unit-dir',
    default=UNIT_DIR,
    help='base directory for systemd units')
subparsers = parser.add_subparsers(help='sub-command')

parser_version = subparsers.add_parser(
    'version', help='get ceph version from container')
parser_version.set_defaults(func=command_version)

parser_ls = subparsers.add_parser(
    'ls', help='list daemon instances on this host')
parser_ls.set_defaults(func=command_ls)

parser_adopt = subparsers.add_parser(
    'adopt', help='adopt daemon deployed with a different tool')
parser_adopt.set_defaults(func=command_adopt)
parser_adopt.add_argument(
    '--name', '-n',
    required=True,
    help='daemon name (type.id)')
parser_adopt.add_argument(
    '--style',
    required=True,
    help='deployment style (legacy, ...)')
parser_adopt.add_argument(
    '--cluster',
    default='ceph',
    help='cluster name')

parser_rm_daemon = subparsers.add_parser(
    'rm-daemon', help='remove daemon instance')
parser_rm_daemon.set_defaults(func=command_rm_daemon)
parser_rm_daemon.add_argument(
    '--name', '-n',
    required=True,
    help='daemon name (type.id)')
parser_rm_daemon.add_argument(
    '--fsid',
    required=True,
    help='cluster FSID')
parser_rm_daemon.add_argument(
    '--force',
    action='store_true',
    help='proceed, even though this may destroy valuable data')

parser_rm_cluster = subparsers.add_parser(
    'rm-cluster', help='remove all daemons for a cluster')
parser_rm_cluster.set_defaults(func=command_rm_cluster)
parser_rm_cluster.add_argument(
    '--fsid',
    required=True,
    help='cluster FSID')
parser_rm_cluster.add_argument(
    '--force',
    action='store_true',
    help='proceed, even though this may destroy valuable data')

parser_run = subparsers.add_parser(
    'run', help='run a ceph daemon, in a container, in the foreground')
parser_run.set_defaults(func=command_run)
parser_run.add_argument(
    '--name', '-n',
    required=True,
    help='daemon name (type.id)')
parser_run.add_argument(
    '--fsid',
    required=True,
    help='cluster FSID')

parser_shell = subparsers.add_parser(
    'shell', help='run an interactive shell inside a daemon container')
parser_shell.set_defaults(func=command_shell)
parser_shell.add_argument(
    '--fsid',
    help='cluster FSID')
parser_shell.add_argument(
    '--name', '-n',
    help='daemon name (type.id)')
parser_shell.add_argument(
    '--config', '-c',
    help='ceph.conf to pass through to the container')
parser_shell.add_argument(
    '--keyring', '-k',
    help='ceph.keyring to pass through to the container')

parser_enter = subparsers.add_parser(
    'enter', help='run an interactive shell inside a running daemon container')
parser_enter.set_defaults(func=command_enter)
parser_enter.add_argument(
    '--fsid',
    required=True,
    help='cluster FSID')
parser_enter.add_argument(
    '--name', '-n',
    required=True,
    help='daemon name (type.id)')

parser_exec = subparsers.add_parser(
    'exec', help='run command inside a running daemon container')
parser_exec.set_defaults(func=command_exec)
parser_exec.add_argument(
    '--fsid',
    required=True,
    help='cluster FSID')
parser_exec.add_argument(
    '--name', '-n',
    required=True,
    help='daemon name (type.id)')
parser_exec.add_argument(
    '--privileged',
    action='store_true',
    help='use a privileged container')
parser_exec.add_argument(
    'command', nargs='+',
    help='command')

parser_ceph_volume = subparsers.add_parser(
    'ceph-volume', help='run ceph-volume inside a container')
parser_ceph_volume.set_defaults(func=command_ceph_volume)
parser_ceph_volume.add_argument(
    '--fsid',
    required=True,
    help='cluster FSID')
parser_ceph_volume.add_argument(
    '--config-and-keyring',
    help='JSON file with config and (client.bootrap-osd) key')
parser_ceph_volume.add_argument(
    'command', nargs='+',
    help='command')

parser_unit = subparsers.add_parser(
    'unit', help='operate on the daemon\'s systemd unit')
parser_unit.set_defaults(func=command_unit)
parser_unit.add_argument(
    'command',
    help='systemd command (start, stop, restart, enable, disable, ...)')
parser_unit.add_argument(
    '--fsid',
    required=True,
    help='cluster FSID')
parser_unit.add_argument(
    '--name', '-n',
    required=True,
    help='daemon name (type.id)')

parser_bootstrap = subparsers.add_parser(
    'bootstrap', help='bootstrap a cluster (mon + mgr daemons)')
parser_bootstrap.set_defaults(func=command_bootstrap)
parser_bootstrap.add_argument(
    '--config', '-c',
    help='ceph conf file to incorporate')
parser_bootstrap.add_argument(
    '--mon-id',
    required=False,
    help='mon id (default: local hostname)')
parser_bootstrap.add_argument(
    '--mon-addrv',
    help='mon IPs (e.g., [v2:localipaddr:3300,v1:localipaddr:6789])')
parser_bootstrap.add_argument(
    '--mon-ip',
    help='mon IP')
parser_bootstrap.add_argument(
    '--mgr-id',
    required=False,
    help='mgr id (default: local hostname)')
parser_bootstrap.add_argument(
    '--fsid',
    help='cluster FSID')
parser_bootstrap.add_argument(
    '--output-keyring',
    help='location to write keyring file with new cluster admin and mon keys')
parser_bootstrap.add_argument(
    '--output-config',
    help='location to write conf file to connect to new cluster')
parser_bootstrap.add_argument(
    '--output-pub-ssh-key',
    help='location to write the cluster\'s public SSH key')
parser_bootstrap.add_argument(
    '--skip-ssh',
    action='store_true',
    help='skip setup of ssh key on local host')

parser_deploy = subparsers.add_parser(
    'deploy', help='deploy a daemon')
parser_deploy.set_defaults(func=command_deploy)
parser_deploy.add_argument(
    '--name',
    required=True,
    help='daemon name (type.id)')
parser_deploy.add_argument(
    '--fsid',
    required=True,
    help='cluster FSID')
parser_deploy.add_argument(
    '--config', '-c',
    help='config file for new daemon')
parser_deploy.add_argument(
    '--keyring',
    help='keyring for new daemon')
parser_deploy.add_argument(
    '--key',
    help='key for new daemon')
parser_deploy.add_argument(
    '--config-and-keyrings',
    help='JSON file with config and keyrings for the daemon and crash agent')
parser_deploy.add_argument(
    '--mon-ip',
    help='mon IP')
parser_deploy.add_argument(
    '--mon-network',
    help='mon network (CIDR)')
parser_deploy.add_argument(
    '--osd-fsid',
    help='OSD uuid, if creating an OSD container')

# allow argv to be injected
try:
    av = injected_argv
except NameError:
    av = sys.argv[1:]

args = parser.parse_args(av)

# podman or docker?
if args.docker:
    podman_path = find_program('docker')
else:
    for i in PODMAN_PREFERENCE:
        try:
            podman_path = find_program(i)
            break
        except Exception as e:
            logging.debug('could not locate %s: %s' % (i, e))
    if not podman_path:
        raise RuntimeError('unable to locate any of %s' % PODMAN_PREFERENCE)

if 'func' not in args:
    sys.stderr.write('No command specified; pass -h or --help for usage\n')
    sys.exit(1)
r = args.func()
if not r:
    r = 0
sys.exit(r)
